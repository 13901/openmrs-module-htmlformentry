package org.openmrs.module.htmlformentry;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.junit.Assert;
import org.openmrs.Concept;
import org.openmrs.Encounter;
import org.openmrs.Form;
import org.openmrs.Obs;
import org.openmrs.Patient;
import org.openmrs.api.context.Context;
import org.openmrs.module.htmlformentry.FormEntryContext.Mode;
import org.openmrs.util.OpenmrsUtil;
import org.springframework.mock.web.MockHttpServletRequest;

public abstract class RegressionTestHelper {
	
	/**
	 * @return will be used to look up the file test/.../include/{formName}.xml   
	 */
	abstract String getFormName();
	
	/**
	 * you probably want to override this
	 * @return the labels before all widgets you want to set values for
	 * (allows you to refer to "Date:" instead of "w1" in setupRequest) 
	 */
	String[] widgetLabels() {
		return new String[0];
	}

	/**
	 * Set any request parameters that will be sent in the form submission
	 * @param request an empty request for you to populate
	 * @param widgets map from the label you provided in widgetLabels() to the name that form element should submit as (which was autogenerated by the html form, e.g. "w3") 
	 */
	abstract void setupRequest(MockHttpServletRequest request, Map<String, String> widgets);
	
	/**
	 * @param results the results of having submitted the request you set up in setupRequest. This will contain either validationErrors, or else an encounterCreated  
	 */
	abstract void testResults(SubmissionResults results);
	
	/**
	 * Optionally override this if you want to generate the form for a different patient
	 * @return
	 */
	Patient getPatient() {
		return Context.getPatientService().getPatient(2);	
	}
	
	public void run() throws Exception {
		Patient patient = getPatient();
		FormEntrySession session = setupFormEntrySession(patient, getFormName());
		String html = session.getHtmlToDisplay();
		//System.out.println(html);
		
		Map<String, String> labeledWidgets = getLabeledWidgets(html, widgetLabels());
		MockHttpServletRequest request = new MockHttpServletRequest();
		setupRequest(request, labeledWidgets);
		
		SubmissionResults results = doSubmission(session, request);
		testResults(results);
	}
	
	private FormEntrySession setupFormEntrySession(Patient patient, String filename) throws Exception {
		String xml = loadXmlFromFile(RegressionTests.XML_DATASET_PATH + filename + ".xml");
		
		HtmlForm fakeForm = new HtmlForm();
        fakeForm.setXmlData(xml);
        fakeForm.setForm(new Form(1));
        FormEntrySession session = new FormEntrySession(patient, null, FormEntryContext.Mode.ENTER, fakeForm);
        return session;
    }
	
	private String loadXmlFromFile(String filename) throws Exception {
		InputStream fileInInputStreamFormat = null;
		
		// try to load the file if its a straight up path to the file or
		// if its a classpath path to the file
		if (new File(filename).exists()) {
			fileInInputStreamFormat = new FileInputStream(filename);
		} else {
			fileInInputStreamFormat = getClass().getClassLoader().getResourceAsStream(filename);
			if (fileInInputStreamFormat == null)
				throw new FileNotFoundException("Unable to find '" + filename + "' in the classpath");
		}
		StringBuilder sb = new StringBuilder();
		BufferedReader r = new BufferedReader(new InputStreamReader(fileInInputStreamFormat, Charset.forName("UTF-8")));
		while (true) {
			String line = r.readLine();
			if (line == null)
				break;
			sb.append(line).append("\n");
		}
		return sb.toString();
    }
	
	String dateAsString(Date date) {
		return Context.getDateFormat().format(date);
	}

	String dateTodayAsString() {
	    return dateAsString(new Date());
    }

	/**
	 * Finds the name of the first widget after each of the given labels. I.e. the first name="w#".
	 */
	private Map<String, String> getLabeledWidgets(String html, String... labels) {
		Map<String, String> ret = new HashMap<String, String>();
		for (String label : labels) {
			int index = html.indexOf(label);
			if (index < 0)
				continue;
			try {
				index = html.indexOf("name=\"w", index);
				index = html.indexOf('"', index) + 1;
				String val = html.substring(index, html.indexOf('"', index + 1));
				ret.put(label, val);
			} catch (Exception ex) {
				// do nothing
			}
		}
		return ret;
    }

	private SubmissionResults doSubmission(FormEntrySession session, HttpServletRequest request) throws Exception {
		SubmissionResults results = new SubmissionResults();
		session.prepareForSubmit();
		List<FormSubmissionError> validationErrors = session.getSubmissionController().validateSubmission(session.getContext(), request);
		if (validationErrors != null && validationErrors.size() > 0) {
			results.setValidationErrors(validationErrors);
			return results;
		}
        session.getSubmissionController().handleFormSubmission(session, request);
        if (session.getContext().getMode() == Mode.ENTER && (session.getSubmissionActions().getEncountersToCreate() == null || session.getSubmissionActions().getEncountersToCreate().size() == 0))
            throw new IllegalArgumentException("This form is not going to create an encounter");
        session.applyActions();
        results.setEncounterCreated(getLastEncounter(session.getPatient()));
        return results;
    }

	private Encounter getLastEncounter(Patient patient) {
	    List<Encounter> encs = Context.getEncounterService().getEncounters(patient, null, null, null, null, null, null, false);
	    if (encs == null || encs.size() == 0)
	    	return null;
	    if (encs.size() == 1)
	    	return encs.get(0);
	    Collections.sort(encs, new Comparator<Encounter>() {
			@Override
            public int compare(Encounter left, Encounter right) {
	            return OpenmrsUtil.compareWithNullAsEarliest(left.getEncounterDatetime(), right.getEncounterDatetime());
            }
	    });
	    return encs.get(encs.size() - 1);
    }

	class SubmissionResults {
		private List<FormSubmissionError> validationErrors; 
		private Encounter encounterCreated;

		public void assertNoEncounterCreated() {
			Assert.assertNull(encounterCreated);
        }
		
		public void assertEncounterCreated() {
			Assert.assertNotNull(encounterCreated);
        }
		
		public void assertNoErrors() {
			Assert.assertTrue(validationErrors == null || validationErrors.size() == 0);
		}
		
		public void assertErrors() {
			Assert.assertTrue(validationErrors != null && validationErrors.size() > 0);
		}
		
		public void assertErrors(int numberOfErrors) {
			Assert.assertTrue(validationErrors != null && validationErrors.size() == numberOfErrors);
		}
		
		public void printErrors() {
	        if (validationErrors == null || validationErrors .size() == 0) {
	        	System.out.println("No Errors");
	        } else {
	        	for (FormSubmissionError error : validationErrors)
	        		System.out.println(error.getId() + " -> " + error.getError());
	        }
        }
		
		public void print() {
            printErrors();
            printEncounterCreated();
        }

		
        public void printEncounterCreated() {
	        if (encounterCreated == null) {
	        	System.out.println("No encounter created");
	        } else {
	        	System.out.println("=== Encounter created ===");
	        	System.out.println("Date: " + encounterCreated.getEncounterDatetime());
	        	System.out.println("Location: " + encounterCreated.getLocation().getName());
	        	System.out.println("Provider: " + encounterCreated.getProvider().getPersonName());
	        	System.out.println("    (obs)");
	        	Collection<Obs> obs = encounterCreated.getAllObs(false);
	        	if (obs == null) {
	        		System.out.println("None");
	        	} else {
	        		for (Obs o : obs) {
	        			System.out.println(o.getConcept().getName() + " -> " + o.getValueAsString(Context.getLocale()));
	        		}
	        	}
	        }
        }

		public List<FormSubmissionError> getValidationErrors() {
        	return validationErrors;
        }
        public void setValidationErrors(List<FormSubmissionError> validationErrors) {
        	this.validationErrors = validationErrors;
        }
        public Encounter getEncounterCreated() {
        	return encounterCreated;
        }
        public void setEncounterCreated(Encounter encounterCreated) {
        	this.encounterCreated = encounterCreated;
        }

        /**
         * Fails if the number of obs in encounterCreated is not 'expected'
         * @param expected
         */
		public void assertObsCreatedCount(int expected) {
			int found = getObsCreatedCount();
	        Assert.assertEquals("Expected to create " + expected + " obs but got " + found, expected, found);
        }

		/**
		 * @return the number of obs in encounterCreated (0 if no encounter was created)
		 */
		public int getObsCreatedCount() {
	        if (encounterCreated == null)
	        	return 0;
	        Collection<Obs> temp = encounterCreated.getAllObs();
	        if (temp == null)
	        	return 0;
	        return temp.size();
        }

		public void assertObsCreated(int conceptId, Object value) {
			String valueAsString = value.toString();
			if (value instanceof Concept)
				valueAsString = ((Concept) value).getName(Context.getLocale()).getName();
	        Assert.assertNotNull(encounterCreated);
	        Collection<Obs> temp = encounterCreated.getAllObs();
	        Assert.assertNotNull(temp);
	        for (Obs obs : temp) {
	        	if (obs.getConcept().getConceptId() == conceptId) {
	        		if (valueAsString == null)
	        			return;
	        		if (valueAsString.equals(obs.getValueAsString(Context.getLocale())))
	        			return;
	        	}
	        }
	        Assert.assertTrue("Could not find obs with conceptId " + conceptId + " and value " + valueAsString, false);
        }
	}

}
